<script>
	/*********************************************************************************************************/

	/*********************************************************************************************************/
	/***************************************** BD IndexedDB ******************************************/
	const DB = (() => {
		// Open or create the database with multiple stores
		const openDB = (dbName, storeNames, version = 1) => {
			return new Promise((resolve, reject) => {
				const request = indexedDB.open(dbName, version);

				request.onupgradeneeded = (event) => {
					const db = event.target.result;

					// Create multiple object stores if they don't exist
					storeNames.forEach((storeName) => {
						if (!db.objectStoreNames.contains(storeName)) {
							db.createObjectStore(storeName, { keyPath: 'id' });
						}
					});
				};

				request.onsuccess = (event) => {
					resolve(event.target.result);
				};

				request.onerror = (event) => {
					reject(`IndexedDB error: ${event.target.errorCode}`);
				};
			});
		};

		// Add or update an item in a specific store
		const saveItem = async (dbName, storeName, data) => {
			const db = await openDB(dbName, [storeName]);
			return new Promise((resolve, reject) => {
				const transaction = db.transaction(storeName, 'readwrite');
				const store = transaction.objectStore(storeName);
				const request = store.put(data);

				request.onsuccess = () => resolve(true);
				request.onerror = (event) => reject(`Save failed: ${event.target.errorCode}`);
			});
		};

		// Get a single item by key from a specific store
		const getItem = async (dbName, storeName, key) => {
			const db = await openDB(dbName, [storeName]);
			return new Promise((resolve, reject) => {
				const transaction = db.transaction(storeName, 'readonly');
				const store = transaction.objectStore(storeName);
				const request = store.get(key);

				request.onsuccess = () => resolve(request.result);
				request.onerror = (event) => reject(`Get failed: ${event.target.errorCode}`);
			});
		};

		// Get all items from a specific store
		const getAllItems = async (dbName, storeName) => {
			const db = await openDB(dbName, [storeName]);
			return new Promise((resolve, reject) => {
				const transaction = db.transaction(storeName, 'readonly');
				const store = transaction.objectStore(storeName);
				const request = store.getAll();

				request.onsuccess = () => resolve(request.result);
				request.onerror = (event) => reject(`Get all failed: ${event.target.errorCode}`);
			});
		};

		// Delete an item by key from a specific store
		const deleteItem = async (dbName, storeName, key) => {
			const db = await openDB(dbName, [storeName]);
			return new Promise((resolve, reject) => {
				const transaction = db.transaction(storeName, 'readwrite');
				const store = transaction.objectStore(storeName);
				const request = store.delete(key);

				request.onsuccess = () => resolve(true);
				request.onerror = (event) => reject(`Delete failed: ${event.target.errorCode}`);
			});
		};

		// Clear all items from a specific store
		const clearStore = async (dbName, storeName) => {
			const db = await openDB(dbName, [storeName]);
			return new Promise((resolve, reject) => {
				const transaction = db.transaction(storeName, 'readwrite');
				const store = transaction.objectStore(storeName);
				const request = store.clear();

				request.onsuccess = () => resolve(true);
				request.onerror = (event) => reject(`Clear failed: ${event.target.errorCode}`);
			});
		};

		return {
			openDB,
			saveItem,
			getItem,
			getAllItems,
			deleteItem,
			clearStore,
		};
	})();

	/*********************************************************************************************************/
	/*
		/*										   VARIABLES GLOBALES
		/*
		/*********************************************************************************************************/
	(async () => {
		const dbName = 'AgendaCom';
		const storeNames = ['Events', 'Preferences', 'Logs', 'Variables'];
		await DB.openDB(dbName, storeNames);
	})();

	const contentCalendar = document.querySelector('#content-calendar');

	let viewMode = 'week';

	let selectedDate = '';
	let [firstDayOfWeek, lastDayOfWeek] = [];

	/***************************************** Initialisation ***********************************************/

	let flatDatePicker = '';
	function changePickerDate(date, instance = flatDatePicker) {
		if (instance != '') {
			instance.setDate(date);
		}
	}

	flatDatePicker = flatpickr('#menuDatePicker', {
		inline: true,
		defaultDate: selectedDate,
		locale: {
			firstDayOfWeek: 1,

			weekdays: {
				shorthand: ['D', 'L', 'M', 'M', 'J', 'J', 'S'],
				longhand: ['dim', 'lun', 'mar', 'mer', 'jeu', 'ven', 'sam'],
			},

			months: {
				shorthand: ['Janv', 'Févr', 'Mars', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sept', 'Oct', 'Nov', 'Déc'],
				longhand: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
			},

			ordinal: (nth) => {
				if (nth > 1) return '';

				return 'er';
			},
			rangeSeparator: ' au ',
			weekAbbreviation: 'Sem',
			scrollTitle: 'Défiler pour augmenter la valeur',
			toggleTitle: 'Cliquer pour basculer',
			time_24hr: true,
		},
		onReady: function (selectedDates, dateStr, instance) {
			if (viewMode == 'week') {
				instance.set('mode', 'range');
				changePickerDate([firstDayOfWeek, lastDayOfWeek], instance);
			} else {
				instance.set('mode', 'single');
			}
			document.querySelectorAll('.flatpickr-monthDropdown-month').forEach((month) => {
				month.textContent = month.textContent.charAt(0).toUpperCase() + month.textContent.slice(1);
			});
		},
		onDayCreate: function (dObj, dStr, fp, dayElem) {},
		onChange: function (selectedDates, dateStr, instance) {
			updateDaysSelected(selectedDates[0]);
		},
	});

	checkReseaux();

	updateDaysSelected(new Date());

	DB.getItem('AgendaCom', 'Preferences', 'darkMode').then((result) => {
		if (result) {
			document.querySelector('html').toggleAttribute('dark', result);
		}
	});

	function addInitalKey() {
		const keysEvent = formatEvent([], 'Event', 0, true);

		const keys = [...keysEvent];
		const keysList = {};
		keysEvent.forEach((key) => {
			const tableau = 'Objectifs ' + new Date(selectedDate).getFullYear();
			keysList['c_s_' + key + '_' + tableau] = { id: 'c_s_' + key + '_' + tableau, value: key, selected: false };
			switch (key) {
				case 'reseau':
				case 'date':
				case 'titre':
				case 'type':
					keysList['c_s_' + key + '_' + tableau].selected = true;
					break;
				default:
					keysList['c_s_' + key + '_' + tableau].selected = false;
					break;
			}
		});

		DB.saveItem('AgendaCom', 'Preferences', { id: 'whatToShow', value: keysList });
	}

	DB.getItem('AgendaCom', 'Preferences', 'whatToShow').then((result) => {
		if (!result) {
			addInitalKey();
		}
	});

	/***************************************** Fonctions fondamentales ***********************************************/

	function calendarUpdate() {
		switch (viewMode) {
			case 'week':
			default:
				createColumnsWeek();
				break;
			case 'day':
				createColumnsDay();
				break;
		}
		// Récupération des événements
		const dateAtStart = getFirstAndLastDayOfWeek(selectedDate)[0];
		retrieveEvents('Objectifs ' + new Date(selectedDate).getFullYear(), dateAtStart);
		// Affichage des événements
		displayEvents();
	}

	function createColumnsWeek() {
		contentCalendar.querySelectorAll('.calendar-columns').forEach((column) => column.remove());
		const fakeFirstDayOfWeek = new Date(firstDayOfWeek);
		const todayDate = new Date();
		for (let i = 0; i < 7; i++) {
			const columns = document.createElement('div');
			let dateStr = '';
			if (window.innerWidth <= 1250) {
				dateStr = fakeFirstDayOfWeek.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric', month: 'short' });
			} else {
				dateStr = fakeFirstDayOfWeek.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
			}
			let styleCustom = '';
			if (fakeFirstDayOfWeek.toLocaleDateString() == todayDate.toLocaleDateString()) {
				styleCustom = 'style="font-weight: 700;"';
			}
			columns.className = 'calendar-columns';
			columns.dataset.identifier = formatDate(fakeFirstDayOfWeek);
			columns.innerHTML = `
					<div class="calendar-columns-header">
							<span class="calendar-columns-header-title" ${styleCustom}>${dateStr}</span>
							<div class="calendar-columns-header-info"></div>
					</div>
					<div class="calendar-columns-content"></div>`;
			fakeFirstDayOfWeek.setDate(fakeFirstDayOfWeek.getDate() + 1);
			contentCalendar.appendChild(columns);
		}
	}

	function updateDaysSelected(date) {
		selectedDate = date;
		[firstDayOfWeek, lastDayOfWeek] = getFirstAndLastDayOfWeek(selectedDate);
		if (viewMode == 'week') {
			flatDatePicker.set('mode', 'range');
			changePickerDate([firstDayOfWeek, lastDayOfWeek]);
		} else {
			flatDatePicker.set('mode', 'single');
		}
		calendarUpdate();
	}

	function navigationNext() {
		if (viewMode == 'week') {
			selectedDate.setDate(selectedDate.getDate() + 7);
		} else {
			selectedDate.setDate(selectedDate.getDate() + 1);
		}
		updateDaysSelected(selectedDate);
	}

	function navigationPrevious() {
		if (viewMode == 'week') {
			selectedDate.setDate(selectedDate.getDate() - 7);
		} else {
			selectedDate.setDate(selectedDate.getDate() - 1);
		}
		updateDaysSelected(selectedDate);
	}

	function formatEvent(event, tableau, ligne, getListKeys = false) {
		const format = {
			id: event[COL_ID] + '_' + tableau,
			tableau: tableau,
			ligne: ligne,
			reseau: event[COL_RESEAU],
			date: event[COL_DATE] ? convertAbregedStringToDate(event[COL_DATE]) : '',
		};
		if (getListKeys) {
			return Object.keys(format);
		} else {
			return format;
		}
	}

	async function retrieveEvents(tableau = 'Event', dateAtStart, pushToDB = true) {
		let range = '';
		let ligneToStart = 2;
		let lastEventUpdate = await DB.getItem('AgendaCom', 'Variables', 'lastEventUpdate');
		if (lastEventUpdate) {
			lastEventUpdate = lastEventUpdate['value'];
		}
		if (!lastEventUpdate || new Date(lastEventUpdate).getTime() < new Date().getTime() - 15000) {
			range = tableau + '!' + colonneMin + '' + ligneToStart + ':' + colonneMax;
			google.script.run.withSuccessHandler(eventRetrieved).withFailureHandler(errorHandler).getDataFromSpreadsheet(range, 'base');

			await DB.saveItem('AgendaCom', 'Variables', { id: 'lastEventUpdate', value: new Date() });
		} else {
			console.log(
				'Récupération des événements déjà effectuée il y a moins de 15 secondes (' + Math.abs((new Date(lastEventUpdate).getTime() - new Date().getTime()) / 1000) + ')'
			);
		}

		async function eventRetrieved(events) {
			console.log('Récupération des événements : ', events);
			if (!comparerObjets(dateAtStart, getFirstAndLastDayOfWeek(selectedDate)[0])) {
				console.log('Dates de la semaine changées');
				return;
			}
			let missingKey = [];
			console.groupCollapsed('Récupération des événements ' + tableau);
			let ligne = ligneToStart;
			let eventsJSON = {};
			events.forEach(async (event) => {
				ligne += 1;
				if (event[0] != '') {
					if (!event[COL_ID]) {
						missingKey.push("Clé primaire manquante pour l'événement ligne " + (ligne - 1) + ' dans ' + tableau + ' : ', event);
					} else {
						const formatedEvent = await formatEvent(event, tableau, ligne - 1);
						eventsJSON[event[COL_ID] + '_' + tableau] = formatedEvent;
					}
				}
			});
			if (pushToDB) {
				const allEvents = (await DB.getAllItems('AgendaCom', `Events`)) || [];
				const allReseau = await DB.getAllItems('AgendaCom', 'Variables');
				let eventsToSave = {};
				console.time('Comparaison des événements');
				allEvents.forEach(async (event) => {
					if (!eventsJSON[event.id]) {
						console.log('Event supprimé : ', event.id);
						await DB.deleteItem('AgendaCom', `Events`, event.id);
					}
				});
				console.timeEnd('Comparaison des événements');
				console.time('Sauvegarde des événements');
				console.log(eventsJSON);
				eventsJSON = Object.values(eventsJSON);
				eventsJSON.forEach(async (event) => {
					if (!allEvents.find((e) => e.id == event.id)) {
						eventsToSave[event.id] = event;
					} else {
						if (
							!comparerObjets(
								allEvents.find((e) => e.id == event.id),
								event
							)
						) {
							eventsToSave[event.id] = event;
							console.log(
								'Event modifié : \n Ancien : ',
								allEvents.find((e) => e.id == event.id),
								'\n Nouveau : ',
								event
							);
						}
					}

					if (!allReseau.find((s) => s.id == event.reseau)) {
						ajusterReseau(event.reseau);
					}
				});
				console.timeEnd('Sauvegarde des événements');
				console.time('Sauvegarde des événements dans la base de données');

				if (_.isEmpty(eventsToSave)) {
					console.log('Aucun événement à sauvegarder');
				} else {
					eventsToSave = Object.values(eventsToSave);
					eventsToSave.forEach(async (event) => {
						await DB.saveItem('AgendaCom', `Events`, event);
					});
					console.log('Il y a ', eventsToSave.length, ' événements à sauvegarder');
					displayEvents();
				}
				console.timeEnd('Sauvegarde des événements dans la base de données');
				console.log('Events sauvegardés dans la base de données');
			} else {
				console.groupEnd();
				return eventsJSON;
			}
			console.groupEnd();
			if (missingKey.length > 0) {
				console.groupCollapsed('Clés manquantes');
				console.log(missingKey);
				console.groupEnd();
			}
		}

		function errorHandler(error) {
			popUp('red', 8000, 'Erreur lors de la récupération des événements', error, 'error', true);
		}
	}
	/***************************************** Gestions des reseaux ***********************************************/

	function checkReseaux() {
		for (const roomName in listeReseauJSON) {
			ajusterReseau(roomName);
		}

		google.script.run.withSuccessHandler(reseauxRetrieve).withFailureHandler(errorRetrieve).getDataFromSpreadsheet('Listes!A2:A');

		function reseauxRetrieve(reseaux) {
			reseaux.forEach((reseau) => {
				if (!listeReseauJSON.hasOwnProperty([reseau[0]])) {
					listeReseauJSON[reseau[0]] = { id: reseau[0], couleur: '#F1C8DB', show: true };
				}
			});
		}

		function errorRetrieve() {
			console.error('Erreur lors de la récupération des reseaux');
		}
	}

	// Gestions des reseaux modifié/n'existant pas
	async function ajusterReseau(reseau, getColor = false) {
		let reseauEdit = reseau;
		if (!getColor) {
			if (!listeReseauJSON[reseauEdit]) {
				const couleurReseau = '#CDC1FF';
				const couleurTexte = darkenColor(couleurReseau, 0.5);
				console.log('Reseau ajustée :', reseauEdit, ' - ', couleurReseau, ' - ', couleurTexte);
				await DB.saveItem('AgendaCom', 'Variables', { id: reseauEdit, couleurReseau: couleurReseau, couleurTexte: couleurTexte, show: false });
			} else {
				const allReseaux = await DB.getAllItems('AgendaCom', 'Variables');
				if (!allReseaux.find((s) => s.id == reseauEdit)) {
					const couleurReseau = listeReseauJSON[reseauEdit].couleur;
					const couleurTexte = darkenColor(couleurReseau, 0.5);
					const show = listeReseauJSON[reseauEdit].show;
					await DB.saveItem('AgendaCom', 'Variables', { id: reseauEdit, couleurReseau: couleurReseau, couleurTexte: couleurTexte, show: show });
				}
			}
		} else {
			return listeReseauJSON[reseauEdit].couleur;
		}
	}

	/***************************************** Affichage des événements ***********************************************/

	async function displayEvents() {
		const columns = contentCalendar.querySelectorAll('.calendar-columns');
		const allEvents = await DB.getAllItems('AgendaCom', 'Events');
		let identifier = '';
		columns.forEach((column) => {
			if (viewMode == 'week') {
				identifier = new Date(column.dataset.identifier);
			} else {
				identifier = new Date(selectedDate);
			}
			const eventsFiltered = [];
			column.querySelectorAll('.calendar-event').forEach((event) => event.remove());
			// Récupération des événements depuis la BD
			allEvents.forEach((event) => {
				if (estDansPlageJour(event.date, identifier, identifier, true)) {
					eventsFiltered.push(event);
				}
			});

			appearEventIntoColumns(column, eventsFiltered);
		});
		actualiseZIndex();
	}

	function actualiseZIndex() {
		const columns = contentCalendar.querySelectorAll('.calendar-columns');

		columns.forEach((columns) => {
			const eventContainers = columns.querySelectorAll('.calendar-event-container');
			const sortedEventContainers = Array.from(eventContainers).sort((a, b) => {
				return a.dataset.heureDebut - b.dataset.heureDebut;
			});
			sortedEventContainers.forEach((eventContainer, index) => {
				eventContainer.dataset.zIndex = index + 1;
				const events = eventContainer.querySelectorAll('.calendar-event');
				events.forEach((event) => {
					event.style.zIndex = eventContainer.dataset.zIndex;
				});
			});
			const allEvents = columns.querySelectorAll('.calendar-event');
			allEvents.forEach((event) => {
				const parentContainer = event.closest('.calendar-event-container');
				const zIndex = parentContainer ? parentContainer.dataset.zIndex : 1;
				event.style.zIndex = zIndex;
			});
		});
	}

	async function appearEventIntoColumns(column, eventsList) {
		const allReseau = await DB.getAllItems('AgendaCom', 'Variables');
		const allKeysWhatToShow = await DB.getItem('AgendaCom', 'Preferences', 'whatToShow');
		const keysToShow = Object.values(Object.values(allKeysWhatToShow)[1]);
		eventsList.forEach((event) => {
			let calendarContainer = column.querySelector(`.calendar-event-container[data-heure-debut="${event.heureDebut}"]`);
			if (!calendarContainer) {
				calendarContainer = document.createElement('div');
				calendarContainer.className = 'calendar-event-container';
				calendarContainer.dataset.heureDebut = event.heureDebut;
				calendarContainer.style.width = column.clientWidth + 'px';
				window.addEventListener('resize', () => {
					calendarContainer.style.width = column.clientWidth + 'px';
				});
			}
			const eventElement = document.createElement('div');
			eventElement.className = 'calendar-event';
			eventElement.dataset.id = event.id;
			eventElement.dataset.tableau = event.tableau;
			eventElement.dataset.ligne = event.ligne;
			eventElement.dataset.date = event.date;
			eventElement.dataset.reseau = event.reseau;
			const eventContent = document.createElement('div');
			eventContent.className = 'calendar-event-content';

			eventContent.innerHTML = `
			`;
			let hoursAdded = false;
			let aleardyAdded = [];

			const keysSelectedAndInTableau = keysToShow.filter((key) => key.selected && key.id.includes(event.tableau));
			keysSelectedAndInTableau.forEach((key) => {
				const keyToShow = key.value;
				console.log(keyToShow);
				if (keyToShow == 'date') {
					eventContent.innerHTML += `<div class="calendar-event-content-date">${convertDateToAbregedString(new Date(event.date))}</div>`;
				} else if (keyToShow == 'titre') {
					eventContent.innerHTML += `<div class="calendar-event-content-${keyToShow}" style="white-space: wrap; font-weight: 500; margin-bottom: 0.5vh">${event[keyToShow]}</div>`;
				} else if (keyToShow == 'reseau') {
					eventContent.innerHTML += `<div class="calendar-event-content-${keyToShow}" style="white-space: wrap; font-weight: 500;">${event[keyToShow]}</div>`;
				} else {
					eventContent.innerHTML += `<div class="calendar-event-content-${keyToShow}">${formatString(keyToShow)} : ${event[keyToShow]}</div>`;
				}
			});

			eventElement.appendChild(eventContent);
			calendarContainer.appendChild(eventElement);
			column.querySelector('.calendar-columns-content').appendChild(calendarContainer);

			allReseau.forEach((reseau) => {
				if (reseau.id == event.reseau) {
					eventContent.style.backgroundColor = reseau.couleurReseau || '';
					eventContent.style.color = reseau.couleurTexte || '';
					eventContent.style.borderColor = reseau.couleurTexte || '';

					if (!reseau.show) {
						eventElement.style.height = '0';
					}
				}
			});
			const colorBackground = eventContent.style.backgroundColor;
			const insideHeight = eventContent.scrollHeight;

			eventElement.addEventListener('mouseenter', () => {
				if (eventElement.clientHeight < insideHeight) {
					eventElement.style.height = '100%';
				}
				eventContent.style.backgroundColor = lighterColor(colorBackground, 0.5);
				eventContent.querySelectorAll('div').forEach((element) => {
					element.style.whiteSpace = 'normal';
				});
			});

			eventElement.addEventListener('mouseleave', () => {
				eventContent.style.backgroundColor = colorBackground;
				eventContent.querySelectorAll('div').forEach((element) => {
					element.style.whiteSpace = '';
				});
			});

			eventElement.addEventListener('click', () => {
				appearEventInContenu(event);
			});
		});
	}

	function appearEventInContenu(event) {
		console.log(event);
	}

	/***************************************** Menu & Material Design ******************************************/

	function registerListenerMenuButton(button, menu) {
		const anchorEl = document.body.querySelector(button);
		const menuEl = document.body.querySelector(menu);

		anchorEl.addEventListener('click', () => {
			menuEl.open = !menuEl.open;
		});
	}

	registerListenerMenuButton('#create-event-button', '#create-event-list');

	async function appearReseauxInListLeft() {
		const allReseau = await DB.getAllItems('AgendaCom', 'Variables');
		if (allReseau.length <= 1) {
			setTimeout(() => {
				appearReseauxInListLeft();
			}, 2000);
		} else {
			const listReseaux = document.querySelector('#listeReseaux-menu');
			listReseaux.innerHTML = '';
			// Boutons Tout afficher, Tout masquer, Uniquement Occupées
			const boutonToutAfficher = document.createElement('md-filled-tonal-button');
			boutonToutAfficher.textContent = 'Tout afficher';

			const boutonToutMasquer = document.createElement('md-filled-tonal-button');
			boutonToutMasquer.textContent = 'Tout masquer';

			const boutonUniquementOccupes = document.createElement('md-filled-tonal-button');
			boutonUniquementOccupes.textContent = 'Uniquement Occupées';

			listReseaux.appendChild(boutonToutAfficher);
			listReseaux.appendChild(boutonToutMasquer);
			listReseaux.appendChild(boutonUniquementOccupes);

			boutonToutAfficher.addEventListener('click', async () => {
				allReseau.forEach(async (reseau) => {
					reseau.show = true;
					await DB.saveItem('AgendaCom', 'Variables', reseau);
				});
				document.querySelectorAll('.calendar-event').forEach((event) => {
					event.style.height = '';
				});
				document.querySelectorAll('#listeReseaux-menu label md-checkbox').forEach((checkbox) => {
					checkbox.setAttribute('checked', '');
				});
			});

			boutonToutMasquer.addEventListener('click', async () => {
				allReseau.forEach(async (reseau) => {
					reseau.show = false;
					await DB.saveItem('AgendaCom', 'Variables', reseau);
				});
				document.querySelectorAll('.calendar-event').forEach((event) => {
					event.style.height = '0';
				});
				document.querySelectorAll('#listeReseaux-menu label md-checkbox').forEach((checkbox) => {
					checkbox.removeAttribute('checked');
				});
			});

			boutonUniquementOccupes.addEventListener('click', async () => {
				allReseau.forEach(async (reseau) => {
					const reseauDOM = document.querySelector('.calendar-event[data-reseau="' + reseau.id + '"]');
					const allReseauDOM = document.querySelectorAll('.calendar-event[data-reseau="' + reseau.id + '"]');
					const checkboxDOM = document.querySelector('#listeReseaux-menu label md-checkbox[data-reseau="' + reseau.id + '"]');
					if (reseauDOM) {
						reseau.show = true;
						allReseauDOM.forEach((event) => {
							event.style.height = '';
						});
						checkboxDOM.setAttribute('checked', '');
					} else {
						reseau.show = false;
						allReseauDOM.forEach((event) => {
							event.style.height = '0';
						});
						checkboxDOM.removeAttribute('checked');
					}
					await DB.saveItem('AgendaCom', 'Variables', reseau);
				});
			});

			for (const reseau in listeReseauJSON) {
				const reseauLabel = document.createElement('label');
				const reseauCheckbox = document.createElement('md-checkbox');
				reseauCheckbox.dataset.reseau = reseau;
				reseauCheckbox.setAttribute('touch-target', 'wrapper');
				if (allReseau.find((s) => s.id == reseau && s.show)) {
					reseauCheckbox.setAttribute('checked', '');
				}
				reseauLabel.appendChild(reseauCheckbox);
				reseauLabel.appendChild(document.createTextNode(reseau));
				listReseaux.appendChild(reseauLabel);

				reseauCheckbox.addEventListener('change', async (event) => {
					const allReseau = await DB.getAllItems('AgendaCom', 'Variables');
					const reseauToChange = allReseau.find((s) => s.id == reseau);
					reseauToChange.show = reseauCheckbox.checked;
					await DB.saveItem('AgendaCom', 'Variables', reseauToChange);
					document.querySelectorAll('.calendar-event').forEach((event) => {
						if (event.dataset.reseau == reseau) {
							event.style.height = reseauCheckbox.checked ? '' : '0';
						}
					});
				});
			}
		}
	}

	appearReseauxInListLeft();

	// Gestion des boutons menu droite

	const changeThemeButton = document.querySelector('#change-theme-button');

	changeThemeButton.addEventListener('click', () => {
		document.querySelector('html').toggleAttribute('dark');
		DB.saveItem('AgendaCom', 'Preferences', { id: 'darkMode', darkMode: document.querySelector('html').hasAttribute('dark') });
	});

	const elementToShowBtn = document.querySelector('#what-see-event-button');
	const elementToShowList = document.querySelector('#what-see-event-checkbox-list');

	async function generateListElementToShow() {
		const allKeys = await DB.getItem('AgendaCom', 'Preferences', 'whatToShow');

		if (!allKeys) {
			setTimeout(() => {
				generateListElementToShow();
			}, 2000);
		}

		const keysArray = Object.values(Object.values(allKeys)[1]);
		const keysEvent = keysArray.filter((key) => {
			return key.id && key.id.includes('_Event');
		});
		const keysMed = keysArray.filter((key) => {
			return key.id && key.id.includes('_Med');
		});

		const title = document.createElement('div');
		title.textContent = 'Liste Éléments';
		title.className = 'titleList';
		elementToShowList.appendChild(title);

		keysEvent.forEach((key) => {
			const element = document.createElement('label');
			const mdCheckbox = document.createElement('md-checkbox');
			mdCheckbox.dataset.tableau = 'Event';
			mdCheckbox.id = key.id;
			if (key.selected) {
				mdCheckbox.setAttribute('checked', '');
			}
			mdCheckbox.setAttribute('touch-target', 'wrapper');

			element.appendChild(mdCheckbox);
			const spanValue = document.createElement('span');
			spanValue.textContent = formatString(key.value);
			element.appendChild(spanValue);

			elementToShowList.appendChild(element);
		});

		function registerChangeCheckbox() {
			elementToShowList.querySelectorAll('md-checkbox').forEach((checkbox) => {
				checkbox.addEventListener('change', async (event) => {
					isEditedShowValue = true;
					const key = event.target.id;
					const tableau = event.target.dataset.tableau;
					const allKeys = await DB.getItem('AgendaCom', 'Preferences', 'whatToShow');
					const valueKeys = allKeys.value;
					const keyToChange = valueKeys[key];
					keyToChange.selected = event.target.checked;
					await DB.saveItem('AgendaCom', 'Preferences', { id: 'whatToShow', value: valueKeys });
				});
			});
		}

		registerChangeCheckbox();
	}

	generateListElementToShow();

	// Gestion du Bouton de la liste des éléments à afficher

	let isWindowListenerAddedShowBtn = false;
	let isEditedShowValue = false;

	function windowClickListener(event) {
		if (!elementToShowList.contains(event.target) && !elementToShowBtn.contains(event.target)) {
			elementToShowList.dataset.open = 'false';
			if (isEditedShowValue) {
				isEditedShowValue = false;
				displayEvents();
			}

			window.removeEventListener('click', windowClickListener);
			isWindowListenerAddedShowBtn = false;
			popUp('base', 3000, 'Les éléments à afficher ont été modifiés', '', 'info');
		}
	}

	elementToShowBtn.addEventListener('click', () => {
		elementToShowList.dataset.open = elementToShowList.dataset.open === 'true' ? 'false' : 'true';

		if (!isWindowListenerAddedShowBtn) {
			window.addEventListener('click', windowClickListener);
			isWindowListenerAddedShowBtn = true;
		}
	});

	// Gestion des couleurs des reseaux

	const colorEventBtn = document.querySelector('#color-event-button');
	const colorEventList = document.querySelector('#color-event-list');

	async function generateListReseauColor() {
		const allReseau = await DB.getAllItems('AgendaCom', 'Variables');
		if (allReseau.length <= 0) {
			setTimeout(() => {
				generateListReseauColor();
			}, 2000);
		} else {
			const resetColorBtn = document.createElement('md-filled-tonal-button');
			resetColorBtn.textContent = 'Couleurs par défaut';
			resetColorBtn.addEventListener('click', async () => {
				allReseau.forEach(async (reseau) => {
					const couleurReseau = await ajusterReseau(reseau.id, true);
					reseau.couleurReseau = couleurReseau;

					const couleurTexte = darkenColor(couleurReseau, 0.5);
					reseau.couleurTexte = couleurTexte;
					await DB.saveItem('AgendaCom', 'Variables', reseau);
					document.querySelectorAll('.calendar-event').forEach((event) => {
						if (event.dataset.reseau == reseau.id) {
							event.querySelector('.calendar-event-content').style.backgroundColor = couleurReseau;
							event.querySelector('.calendar-event-content').style.color = couleurTexte;
							event.querySelector('.calendar-event-content').style.borderColor = couleurTexte;
							document.querySelector('#color-event-list input[data-reseau="' + event.dataset.reseau + '"]').value = couleurReseau;
						}
					});
				});
			});

			colorEventList.appendChild(resetColorBtn);

			for (const reseau in listeReseauJSON) {
				const reseauLabel = document.createElement('label');
				const reseauColorBox = document.createElement('input');
				reseauColorBox.type = 'color';
				reseauColorBox.dataset.reseau = reseau;
				const reseauArray = allReseau.find((s) => s.id == reseau);
				if (reseauArray) {
					reseauColorBox.value = reseauArray.couleurReseau;

					reseauLabel.appendChild(reseauColorBox);
					const spanValue = document.createElement('span');
					spanValue.textContent = reseau;
					reseauLabel.appendChild(spanValue);
					colorEventList.appendChild(reseauLabel);

					reseauColorBox.addEventListener('change', async (event) => {
						const allReseau = await DB.getAllItems('AgendaCom', 'Variables');
						const reseauToChange = allReseau.find((s) => s.id == reseau);
						reseauToChange.couleurReseau = reseauColorBox.value;
						await DB.saveItem('AgendaCom', 'Variables', reseauToChange);
						document.querySelectorAll('.calendar-event').forEach((event) => {
							if (event.dataset.reseau == reseau) {
								event.querySelector('.calendar-event-content').style.backgroundColor = reseauColorBox.value;
								event.querySelector('.calendar-event-content').style.color = darkenColor(reseauColorBox.value, 0.5);
								event.querySelector('.calendar-event-content').style.borderColor = darkenColor(reseauColorBox.value, 0.5);
							}
						});
					});
				} else {
					console.error('Reseau non trouvée : ', reseau);
				}
			}
		}
	}

	generateListReseauColor();

	// Gestion du Bouton de la liste des couleurs des reseaux
	let isWindowListenerAddedColorEventBtn = false;

	function windowClickListenerColor(event) {
		if (!colorEventList.contains(event.target) && !colorEventBtn.contains(event.target)) {
			colorEventList.dataset.open = 'false';
			window.removeEventListener('click', windowClickListenerColor);
			isWindowListenerAddedColorEventBtn = false;
			popUp('base', 3000, 'Les couleurs des reseaux ont été modifiées', '', 'info');
		}
	}

	colorEventBtn.addEventListener('click', () => {
		colorEventList.dataset.open = colorEventList.dataset.open === 'true' ? 'false' : 'true';

		if (!isWindowListenerAddedColorEventBtn) {
			window.addEventListener('click', windowClickListenerColor);
			isWindowListenerAddedColorEventBtn = true;
		}
	});

	// Gestions des Tabs Menu de Droite

	const tabsMenuRight = document.querySelector('#menu-right md-tabs');
	const tabContent = document.querySelector('#menu-right div#content-tab');
	const tabSettings = document.querySelector('#menu-right div#settings-tab');

	// Initialisation des tabs
	tabSettings.style.display = 'none';

	tabsMenuRight.addEventListener('change', (event) => {
		if (tabContent.hasAttribute('hidden')) {
			tabContent.style.display = '';
			tabContent.removeAttribute('hidden');
			tabSettings.setAttribute('hidden', '');
			tabSettings.style.display = 'none';
		} else {
			tabContent.style.display = 'none';
			tabContent.setAttribute('hidden', '');
			tabSettings.removeAttribute('hidden');
			tabSettings.style.display = '';
		}
	});

	document.querySelectorAll('.viewModeBtn').forEach((btn) => {
		btn.addEventListener('click', (event) => {
			if (!event.target.classList.contains('selected')) {
				viewMode = event.target.getAttribute('data-view');
				document.querySelectorAll('.viewModeBtn').forEach((btn) => btn.classList.remove('selected'));
				event.target.classList.add('selected');
			} else {
				popUp('base', 8000, 'La vue est déjà sélectionnée', '', 'info');
			}
		});
	});

	/***************************************** Usefull Functions ******************************************/

	/**
	 * Vérifie si une date donnée est dans une plage horaire spécifiée.
	 * @param {Date} date - La date à vérifier.
	 * @param {Date} debut - La date de début de la plage horaire.
	 * @param {Date} fin - La date de fin de la plage horaire.
	 * @returns {boolean} - True si la date est dans la plage horaire, sinon False.
	 * @throws {Error} - Si les paramètres ne sont pas de type Date ou s'ils ne sont pas des objets Date valides.
	 */
	function estDansPlageJour(date, debut, fin, day = false) {
		if (!(date instanceof Date) || !(debut instanceof Date) || !(fin instanceof Date)) {
			throw new Error('Tout les paramètres doivent être des objets Date.');
		}

		if (day) {
			date.setHours(0, 0, 0, 0);
			debut.setHours(0, 0, 0, 0);
			fin.setHours(0, 0, 0, 0);
		}

		let timestampDate = date.getTime();
		let timestampDebut = debut.getTime();
		let timestampFin = fin.getTime();

		if (isNaN(timestampDate) || isNaN(timestampDebut) || isNaN(timestampFin)) {
			throw new Error('Tout les paramètres doivent être des objets Date.');
		}

		// Vérifier si la valeur donnée est dans la plage horaire
		return timestampDate >= timestampDebut && timestampDate <= timestampFin;
	}

	/**
	 * Renvoie le premier et le dernier jour de la semaine pour une date donnée.
	 * @param {Date} date - La date pour laquelle calculer le premier et le dernier jour de la semaine.
	 * @returns {Array<Date>} Un tableau contenant le premier et le dernier jour de la semaine.
	 */
	function getFirstAndLastDayOfWeek(date) {
		const currentDate = new Date(date);

		// Obtenir le jour de la semaine (0 pour dimanche, 1 pour lundi, etc.)
		const dayOfWeek = currentDate.getDay();

		// Cloner la date et réinitialiser l'heure à minuit pour éviter les problèmes d'heure
		const firstDayOfWeek = new Date(currentDate);
		firstDayOfWeek.setHours(0, 0, 0, 0);

		// Définir le premier jour de la semaine (lundi)
		firstDayOfWeek.setDate(currentDate.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1));

		// Cloner la date pour obtenir le dernier jour de la semaine (dimanche)
		const lastDayOfWeek = new Date(firstDayOfWeek);
		lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);

		return [firstDayOfWeek, lastDayOfWeek];
	}

	/**
	 * Affiche une fenêtre contextuelle avec un message personnalisé.
	 * @param {string} type - Le type de la fenêtre contextuelle : green,red et yellow (par défaut: 'green').
	 * @param {number} time - La durée d'affichage de la fenêtre contextuelle en millisecondes (par défaut: 8000).
	 * @param {string} titre - Le titre de la fenêtre contextuelle.
	 * @param {string} message - Le message de la fenêtre contextuelle.
	 * @param {string} google_icon - L'icône Google Font à afficher dans la fenêtre contextuelle.
	 */
	function popUp(type = 'base', time = 8000, titre = '', message = '', google_icon = '', copy = false) {
		const google_icon_svg = `<span class="material-symbols-rounded">${google_icon}</span>`;
		const errorContainer = document.createElement('div');
		errorContainer.classList.add('popup-container');

		const errorNotifContainer = document.createElement('div');
		errorNotifContainer.classList.add(`${type}-notif`);
		if (typeof message === 'object') {
			message = JSON.stringify(message, null, 2);
		}

		if (type == 'red') {
			console.error(titre + ' : ' + message);
		}

		const ContentContainer = document.createElement('div');

		if (copy == true && type == 'red') {
			ContentContainer.innerHTML = `<span id="title-popup">${google_icon_svg}${titre}</span><br><span id="content-popup">${message}<br><md-outlined-button class="width-100">Copier l'erreur</md-outlined-button></span>`;

			ContentContainer.querySelector('md-outlined-button').addEventListener('click', () => {
				if (navigator.clipboard) {
					navigator.clipboard.writeText(message).then(
						function () {
							console.log('Texte copié dans le presse-papiers : ' + message);
							alert(
								'Erreur Copié dans le presse-papiers, pour résoudre ce problème veuillez contacter Alexis Thierry-Bellefond ( alexis.thierry-bellefond@paris.fr )'
							);
						},
						function (err) {
							console.error('Erreur lors de la copie dans le presse-papiers', err);
						}
					);
				} else {
					console.error("L'API du presse-papiers n'est pas supportée par ce navigateur.");
				}
			});
		} else {
			ContentContainer.innerHTML = `<span id="title-popup">${google_icon_svg}${titre}</span><br><span id="content-popup">${message}</span>`;
		}

		errorNotifContainer.appendChild(ContentContainer);
		errorContainer.appendChild(errorNotifContainer);
		document.body.appendChild(errorContainer);
		errorContainer.animate(
			[
				{
					opacity: '0.2',
					bottom: '-30%',
				},
				{
					opacity: '1',
					bottom: '2vh',
				},
			],
			{
				duration: 500,
				fill: 'forwards',
			}
		);

		setTimeout(() => {
			errorContainer.animate(
				[
					{
						opacity: '1',
						bottom: '2vh',
					},
					{
						opacity: '0.2',
						bottom: '-30%',
					},
				],
				{
					duration: 500,
					fill: 'forwards',
				}
			);
			setTimeout(() => {
				errorContainer.remove();
			}, 500);
		}, time);
	}

	/**
	 * Compare deux objets JavaScript ou tableaux pour l'égalité, en prenant en compte leurs propriétés et valeurs imbriquées.
	 * Gère également un cas particulier où la valeur de chaîne "(8) La Bulle" est traitée comme équivalente à "(8) Buvette - La Bulle".
	 * @param {object|array} objet1 - Le premier objet ou tableau à comparer. Peut être de tout type.
	 * @param {object|array} objet2 - Le deuxième objet ou tableau à comparer. Doit être du même type que objet1.
	 * @return {boolean} Un booléen indiquant si les deux objets sont égaux ou non. S'ils sont égaux, renvoie true ; sinon, renvoie false.
	 */
	function comparerObjets(objet1, objet2) {
		return _.isEqual(objet1, objet2);
	}

	function convertAbregedStringToDate(dateString, lineInTable = null) {
		const monthsMap = {
			'janv.': 0,
			'févr.': 1,
			mars: 2,
			'avr.': 3,
			mai: 4,
			juin: 5,
			'juil.': 6,
			août: 7,
			'sept.': 8,
			'oct.': 9,
			'nov.': 10,
			'déc.': 11,
			janvier: 0,
			février: 1,
			avril: 3,
			juillet: 6,
			septembre: 8,
			octobre: 9,
			novembre: 10,
			décembre: 11,
		};

		try {
			let dateSplit = dateString.split(' ');
			let day = parseInt(dateSplit[1]);
			let month = monthsMap[dateSplit[2]];
			let year = parseInt(dateSplit[3]) + 2000;
			// Création de la date en spécifiant l'heure à midi pour éviter les problèmes de fuseau horaire
			return new Date(Date.UTC(year, month, day, 12, 0, 0, 0));
		} catch (error) {
			console.log('Erreur à la ligne ' + lineInTable);
			console.log(dateString);
			console.log('Erreur : ' + error);
			return new Error('Erreur' + error);
		}
	}

	function convertDateToAbregedString(date) {
		const dateUsed = new Date(date);
		const monthsMap = {
			0: 'janv.',
			1: 'févr.',
			2: 'mars',
			3: 'avr.',
			4: 'mai',
			5: 'juin',
			6: 'juil.',
			7: 'août',
			8: 'sept.',
			9: 'oct.',
			10: 'nov.',
			11: 'déc.',
		};

		const dayMap = {
			lundi: 'lun.',
			mardi: 'mar.',
			mercredi: 'mer.',
			jeudi: 'jeu.',
			vendredi: 'ven.',
			samedi: 'sam.',
			dimanche: 'dim.',
		};
		try {
			let dayNumber = dateUsed.getDate() < 10 ? '0' + dateUsed.getDate() : dateUsed.getDate();
			return `${dayMap[dateUsed.toLocaleDateString('fr-FR', { weekday: 'long' })]} ${dayNumber} ${monthsMap[dateUsed.getMonth()]} ${dateUsed.getFullYear() - 2000}`;
		} catch (error) {
			console.log('Erreur : ' + error);
			return new Error('Erreur' + error);
		}
	}

	function formatDate(date) {
		const year = date.getFullYear();
		const month = (date.getMonth() + 1).toString().padStart(2, '0');
		const day = date.getDate().toString().padStart(2, '0');
		return `${year}-${month}-${day}`;
	}

	/**
	 * Assombrit une couleur donnée d'un facteur donné.
	 * @param {string} color - La couleur à assombrir, au format rgb() ou #xxxxxx.
	 * @param {number} factor - Le facteur d'assombrissement, entre 0 et 1.
	 * @return {string} La couleur assombrie, au format rgb() ou #xxxxxx.
	 * @throws {Error} Si la couleur n'est pas au format rgb() ou #xxxxxx.
	 * TODO: Gérer l’exception si il n'y a pas de couleur ou facteur.
	 */
	function darkenColor(color, factor) {
		if (color != undefined) {
			let values;
			if (color.startsWith('rgb(')) {
				values = color
					.replace(/^rgb\(|\)$/g, '')
					.split(',')
					.map(Number);
			} else if (color.startsWith('#')) {
				values = [parseInt(color.slice(1, 3), 16), parseInt(color.slice(3, 5), 16), parseInt(color.slice(5, 7), 16)];
			} else {
				throw new Error('Unsupported color format');
			}
			const darkenedValues = values.map((value) => Math.max(0, Math.floor(value * (1 - factor))));
			let darkenedColor;
			if (color.startsWith('rgb(')) {
				darkenedColor = `rgb(${darkenedValues.join(', ')})`;
			} else if (color.startsWith('#')) {
				darkenedColor = `#${darkenedValues.map((value) => value.toString(16).padStart(2, '0')).join('')}`;
			}
			return darkenedColor;
		} else {
			return '#000000';
		}
	}

	function lighterColor(color, factor) {
		if (color !== undefined) {
			let values;
			if (color.startsWith('rgb(')) {
				values = color
					.replace(/^rgb\(|\)$/g, '')
					.split(',')
					.map(Number);
			} else if (color.startsWith('#')) {
				values = [parseInt(color.slice(1, 3), 16), parseInt(color.slice(3, 5), 16), parseInt(color.slice(5, 7), 16)];
			} else {
				throw new Error('Unsupported color format');
			}

			const lightenedValues = values.map((value) => Math.min(255, Math.floor(value + (255 - value) * factor)));
			let lightenedColor;
			if (color.startsWith('rgb(')) {
				lightenedColor = `rgb(${lightenedValues.join(', ')})`;
			} else if (color.startsWith('#')) {
				lightenedColor = `#${lightenedValues.map((value) => value.toString(16).padStart(2, '0')).join('')}`;
			}
			return lightenedColor;
		} else {
			return '#FFFFFF';
		}
	}

	// Fonction pour formater les chaînes de caractères
	// Exemple : formatString('bonjourToutLeMonde') => 'Bonjour Tout Le Monde'
	function formatString(inputString) {
		let formattedString = inputString.charAt(0).toUpperCase();
		for (let i = 1; i < inputString.length; i++) {
			if (inputString[i] === inputString[i].toUpperCase()) {
				formattedString += ' ' + inputString[i];
			} else {
				formattedString += inputString[i];
			}
		}
		return formattedString;
	}
</script>
